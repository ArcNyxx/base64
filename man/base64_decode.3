.\" base64 - simple encoding library
.\" Copyright (C) 2022 FearlessDoggo21
.\" see LICENCE file for licensing information
.TH BASE64_DECODE 3 base64\-VERSION
.SH NAME
base64_decode \- base64 decode into arbitrary binary data
.SH SYNOPSIS
.EX
#include <base64.h>

void base64_decode(const char *restrict \fIinput\fP, size_t \fIlength\fP,
		char *restrict \fIbuffer\fP);
.EE
.SH DESCRIPTION
\fBbase64_decode\fP(3) decodes base64 data, stored at \fIinput\fP, with the
length of \fIlength\fP bytes into arbitrary binary data, outputteing the
decoded data into \fIbuffer\fP.  If the \fIUSE_EQUALS_SIGN_PADDING\fP macro is
defined, a number of equals signs ('=') permitted as padding at the end will be
ignored.
.SH RETURN VALUE
\fBbase64_decode\fP(3) writes the decoded binary data to \fIbuffer\fP.  A NUL
('\\0') byte is not automatically written to the end of the buffer, string
operations performed on the resulting data will require a length of NUL byte to
be appended.
.SH NOTES
Callers must ensure that \fIbuffer\fP is a pointer to a memory location large
enough to store the data as \fBbase64_decode\fP(3) does not check to ensure a
buffer overflow does not occur.  Use of the \fBbase64_decode_len\fP(3) function
is recommended for determining the output length ahead of time.
.SH EXAMPLE
To create an output buffer, decode data into it, then print the decoded data:
.PP
.EX
#include <base64.h>
#include <stdio.h>
#include <string.h>

int
main(void)
{
	static const char *data = "SGVsbG8gV29ybGQhCg";

	/* creates the output buffer of the exact size necessary */
	size_t len = base64_decode_len(strlen(data));
	char buffer[len + 1];
	buffer[len] = '\\0';

	/* encodes then and prints the encoded data */
	base64_decode(data, strlen(data), buffer);
	printf("%s", buffer);
}
.EE
.SH AUTHOR
Written by FearlessDoggo21.
.SH SEE ALSO
\fBbase64_encode\fP(3), \fBbase64_verify\fP(3), \fBbase64_encode_len\fP(3),
\fBbase64_decode_len\fP(3)
